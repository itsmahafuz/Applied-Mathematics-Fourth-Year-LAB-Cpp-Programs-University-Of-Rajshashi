#include <iostream>
#include <cmath>
#include <iomanip>
#include <vector>
using namespace std;

// Define the system of equations
#define dy_dx(x,y,z) (z)                // dy/dx = z
#define dz_dx(x,y,z) ((x*z*z) - (y*y))  // dz/dx = x*z^2 - y^2

int main()
{
    cout.precision(6);
    cout.setf(ios::fixed);

    int n;
    double x0, y0, z0, h, xn;

    // Step 1: Input initial conditions
    cout << "Enter the initial value of x: ";
    cin >> x0;
    cout << "Enter the initial value of y corresponding to x: ";
    cin >> y0;
    cout << "Enter the initial value of z corresponding to x: ";
    cin >> z0;
    cout << "Enter the value of x up to which you want to find y and z: ";
    cin >> xn;
    cout << "Enter the step size h: ";
    cin >> h;

    n = (xn - x0) / h; // number of steps

    // Arrays using vector
    vector<double> x(n + 1), y(n + 1), z(n + 1);

    // Initial values
    x[0] = x0;
    y[0] = y0;
    z[0] = z0;

    double k1, k2, k3, k4; // for dy/dx
    double l1, l2, l3, l4; // for dz/dx

    // Step 2: RK4 Iteration
    for (int i = 0; i < n; i++)
    {
        // Compute RK4 coefficients
        k1 = h * dy_dx(x[i], y[i], z[i]);
        l1 = h * dz_dx(x[i], y[i], z[i]);

        k2 = h * dy_dx(x[i] + h / 2.0, y[i] + k1 / 2.0, z[i] + l1 / 2.0);
        l2 = h * dz_dx(x[i] + h / 2.0, y[i] + k1 / 2.0, z[i] + l1 / 2.0);

        k3 = h * dy_dx(x[i] + h / 2.0, y[i] + k2 / 2.0, z[i] + l2 / 2.0);
        l3 = h * dz_dx(x[i] + h / 2.0, y[i] + k2 / 2.0, z[i] + l2 / 2.0);

        k4 = h * dy_dx(x[i] + h, y[i] + k3, z[i] + l3);
        l4 = h * dz_dx(x[i] + h, y[i] + k3, z[i] + l3);

        // Update y and z
        y[i + 1] = y[i] + (1.0 / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4);
        z[i + 1] = z[i] + (1.0 / 6.0) * (l1 + 2 * l2 + 2 * l3 + l4);

        // Update x
        x[i + 1] = x[i] + h;
    }

    // Step 3: Print results
    cout << "\nThe values of y and z at different x are:\n";
    for (int i = 0; i <= n; i++)
    {
        cout << "x = " << x[i] << " , y = " << y[i] << " , z = " << z[i] << endl;
    }

    return 0;
}
